# 프로세스

프로세스란 실행중인 프로그램으로서 실행 전까지는 보조기억장치에 저장된 데이터 덩어리지이만 실행이 되면 메모리에 적재가 되고 프로세스가 된다.

- 포그라운 프로세스 : 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- 백그라운 프로세스 : 사용자가 보지 못하는 뒷편에서 실행되는 프로세스. 백그라운 프로세스는 다시 사용자와 상호작용이 가능한 프로세스와 사용자와 상호작용 하지않는 프로세스인 데몬(or 서비스)로 나뉜다.

## 프로세스와 CPU

모든 프로세스는 실행을 위해 CPU를 필요로 한다. 그러나 CPU 자원은 한정되어 있다.
프로세스들은 돌아가며 한정된 시간 만큼만(할당된 시간만) CPU를 이용하게 된다. 프로세스는 프로세스의 할당시간 종료를 알리는 타이머 인터럽트라는 하드웨어 인터럽트가 발생하면 다음 차례의 프로세스의 CPU의 차례를 양보하게된다.

### 프로세스 제어블록(PCB)

차례대로 빠르게 번갈아 수행되는 프로세스들을 관리하기위해 사용되는 자료구조. PCB는 프로세스와 관련된 온갖 정보를 저장하며 마치 프로세스에 달린 태그와 같은 역할 수행
PCB는 프로세스가 생성 시 커널 영역에 생성되며 프로세스가 종료되면 폐기됨. 운영체제는 커널영역에 적재된

#### PCB에 담기는 정보

PCB에 담기는 대표적인 정보들은 

1. 프로세스 ID(PID) : 프로세스를 식별하기 위해 붙이는 ID값. 고유 번호
2. 레지스터 값 : 프로세스가 CPU를 통해 이용하는 여러 레지스터값을 프로세스가 다음 실행을 위해 저장 (ex: 프로그램 카운터 값을 알아야 재개 시 다음 실행 순서를 알 수 있음)따라서 레지스터값을 PCB에 저장한 뒤, 다시 본인 차례가 되었을 때 레지스터 값을 복원해서 실행을 재개한다.
3. 프로세스 상태 : 생성, 대기, 준비, 이용, 종료 등의 프로세스 상태값 저장
4. CPU 스케줄링 정보 : CPU를 돌아가면서 사용하므로 언제 어떻게 CPU를 할당받을지에 대한 정보
5. 메모리 정보 : 프로세스가 현재 메모리의 어느 주소에 저장되어 있는지에 대한 정보
6. 사용한 파일과 입출력장치 정보 : 프로세스가 사용한 입출력장치에 대한 정보

### 문맥 교환

CPU는 한정되어있고 프로세스들은 돌아가며 한정된 시간만큼 CPU를 이용한다. 프로세스가 한정된 CPU사용을 위한 교환 과정은 다음과 같다.

1. 기존에 실행되던 프로세스는 현재까지의 중간 정보를 백업한다. (프로그램카운터등 레지스터값, 메모리 정보, 입출력장치정보 등), 이때 이러한 중간 정보를 문맥(context)라고 한다. 문맥은 다음 순서 때 실행을 재개하기 위한 정보들이라고 할 수 있다. 이 실행 문맥을 잘 저장해두면 언제든 해당 프로세스의 실행을 재개할 수 있다.
2. 다음 실행될 프로세스의 문맥을 복구하며 실행을 재개한다.
   이렇게 기존 실행중인 프로세스의 문맥을 백업하고 새로 실행할 프로세스의 문맥을 복구하는 과정을 문맥 교환(context switch)라고 한다.

### 사용자 영역의 프로세스

PCB는 커널영역에 저장된다. 반면 프로세스는 사용자 영역에 저장되어 실행된다.
사용자 영역에서 프로세스는 특정 영역을 나누어 저장된다. 해당 영역들은 크게 코드 영역(= 텍스트영역) , 데이터 영역, 힙 영역, 스택 영역으로 분류된다(그 외 영역도 존재한다).
코드와 데이터 영역은 영역의 크기가 변하지않아 정적 할당영역이라고도 부른다. 
힙영역과 스택영역은 프로그램 실행 중 영역의 크기가 변할 수 있어서 동적할당역역이라고 부른다.

#### 코드영역

코드 영역에는 말 그대로 코드가 저장된다. 이때 코드는 기계어로 이루어진 명령어를 의미한다. 프로그램은 데이터와 명령어로 구성되는데 그 중 명령어가 저장되는 공간이다.
명령어은 실행 중 수정될 수 없으므로 코드영역은 쓰기가 금지되어있다.(read only)

#### 데이터영역

데이터 영역에는 데이터가 저장되는데 잠깐 사용 후 사라지는 데이터가 아닌 프로그램이 실행중인 내내 유지할 데이터들이 저장된다.(ex 전역변수)

#### 힙영역

사용자가 직접 할당할 수 있는 저장공간이다. 저장공간을 할당 후 프로그래머가 직접 반환하거나 가비지컬렉션에 의해 저장공간이 반환된다.

#### 스택영역

데이터들이 일시적으로 저장되는 저장공간이다. (ex 매개변수, 지역변수)

\*공간을 효율적으로 활용하기 위해 일반적으로 힙영역은 낮은주소에서 높은주소로, 스택영역은 높은주소에서 낮은주소로 할당한다. 즉 반대대는 방향으로 할당된다.

## 프로세스의 상태

프로세스의 상태는 일반적으로 5개로 분류된다. 생성, 준비, 실행, 대기 ,종료 상태이다.

- 생성상태 : 말 그대로 생성된 상태로 방금 메모리에 적재되어 PCB를 할당받은 상태이다.
- 준비상태 : 바로 CPU를 할당 받아 실행할 수 있지만 자신의 차례가 아니라서 기다리는 상태이다. 자신의 차례가 될 때 실행 상태로 변한다.(= 디스패치)
- 실행상태 : CPU를 할당받아 실행중인 상태이다. 할당된 시간을 모두 사용하면 다시 준비상태로 돌아가며 실행상태 중 입출력장치를 사용하게 되면 입출력 작업이 끝날 때 까지 대기상태로 전환된다(입출력 인터럽트 발생할때까지)
- 대기 상태 : 프로세스가 실행 도중 입출력 장치 사용하는 상태로 입출력 작업은 CPU에 비해 느리기때문에 효율적인 CPU 사용을 위해 입출력 사용 프로세스는 잠시 대기상태로 전환된 후 입출력 작업이 끝날 때 (입출력 인터럽트가 발생할 때) 다시 준비상태로 전환되어 차례에 따라 실행된다.
- 종료상태 : 프로세스가 종료된 상태로 PCB, 메모리 영역이 모두 정리되는 상태이다.

## 프로세스의 계층구조

대부분의 운영체제에서 프로세스를 계층적으로 관리한다.(macOS, Linux…) 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스 생성이 가능하다.
이때 새로운 프로세스를 생성한 프로세스 주체를 부모 프로세스, 생성된 프로세스를 자식 프로세스라고 부른다. 자식프로세스는 또 다른 자식 프로세스를 생성할 수 있고 그 자식 프로세스는 다시 자신의 자식 프로세스를 생성할 수 있다. 이렇게 프로세스의 계층 구조가 형성된다.

부모와 프로세스와 자식 프로세스는 완전히 별개의 프로세스이며 다른 PID를 가진다.

- 최초의 프로세스는 pstree 명령어로 확인할 수 있다. (ex : systemd, launchd)

### 프로세스 생성 기법

부모 프로세스는 자식 프로세스를 어떻게 생성할까? 자식 프로세스는 어떠한 과정으로 실행될까?
대부분 운영체제에서는 복제와 옷갈아입기 과정(fork-exec)을 통해 자식 프로세스가 생성된다. 부모 프로세는 fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성하고 자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 다른 프ㅗ그램으로 교체한다.
fork 시스템호출 : 복사본을 자식 프로세스로서 생성하라는 시스템 호출이며 생성된 프로세스는 부모 프로세스의 자원을 상속하게 된다. 복사된 프로세스이지만 PID와 메모리 저장위치는 다르다.
exec 시스탬호출: 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는, 전환하는 시스템호출이다. 기존 프로세스의 메모리 영역 중 코드, 데이터 영역은 새로운 실행 프로그램 내용으로 덮어지고 힙과 스택영역은 초기화된다.
