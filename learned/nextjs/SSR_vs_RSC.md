# SSR과 RSC의 차이점과 RSC의 필요성

## SSR과 RSC의 본질적인 차이

### 1. **SSR (완성된 HTML)**

- **완성된 HTML 생성**: 서버에서 모든 데이터를 가져와 컴포넌트를 렌더링하고, 완성된 HTML을 클라이언트에 전송합니다.
- **하이드레이션 필요**: 클라이언트에서 HTML을 React 컴포넌트로 변환(하이드레이션)해야 UI가 인터랙티브하게 동작합니다.
- **JavaScript 번들 크기**:
  - SSR에서 사용된 모든 컴포넌트(서버에서 렌더링된 것 포함)는 클라이언트로 JavaScript 번들링되어야 합니다.
  - 이는 번들 크기가 커지고 초기 로딩 성능이 저하될 수 있습니다.

### 2. **RSC (React Server Components)**

- **HTML 대신 컴포넌트 트리 전송**: 서버에서 React 컴포넌트를 실행해 생성된 UI 트리를 클라이언트에 전송합니다.
- **하이드레이션 불필요**: 서버에서 처리된 RSC는 하이드레이션을 요구하지 않으며, 클라이언트가 인터랙션이 필요한 부분만 하이드레이션합니다.
- **JavaScript 번들 최소화**:
  - 서버 컴포넌트는 클라이언트에 번들되지 않으므로 JavaScript의 크기를 대폭 줄일 수 있습니다.

---

## RSC를 사용하는 이유

RSC는 다음과 같은 이유로 SSR에 비해 강력한 이점을 제공합니다.

### 1. **JavaScript 번들 크기 감소**

- **SSR의 문제점**: SSR에서 렌더링된 모든 컴포넌트는 클라이언트로 번들링됩니다. 결과적으로, 대규모 애플리케이션에서는 번들 크기가 커져 초기 로드 시간과 실행 속도가 느려집니다.
- **RSC의 장점**: RSC로 작성된 컴포넌트는 클라이언트로 전송되지 않으므로 번들 크기를 줄이고, 네트워크 비용과 초기 로드 시간을 최적화합니다.

### 2. **성능 최적화**

- **SSR**: HTML을 생성한 후, 클라이언트에서 이를 다시 React 상태로 변환(하이드레이션)하는 과정에서 리소스가 소모됩니다.
- **RSC**: 하이드레이션이 필요하지 않은 서버 컴포넌트를 통해 클라이언트의 작업 부담을 줄일 수 있습니다.

### 3. **서버 리소스 활용**

- RSC는 서버의 성능을 활용하여 렌더링을 처리합니다.
- 데이터베이스, API 호출 등 서버와 가까운 작업은 클라이언트 대신 서버에서 실행됩니다.
- 클라이언트는 UI와 인터랙션 처리를 담당하여 더 효율적으로 동작합니다.

### 4. **클라이언트와 서버 간 역할 분리**

- RSC는 클라이언트와 서버의 책임을 명확히 분리합니다.
  - **서버 컴포넌트**: 데이터 페칭, 비즈니스 로직 처리, UI 구성 등 서버에서 처리 가능한 작업.
  - **클라이언트 컴포넌트**: 사용자 인터랙션, 이벤트 처리 등 브라우저에서만 가능한 작업.
- 이를 통해 복잡성을 줄이고 성능을 최적화할 수 있습니다.

---

## SSR과 RSC의 적합한 사용 사례

### **SSR이 적합한 경우**

- 실시간으로 사용자별로 데이터를 다르게 표시해야 할 때.
- 모든 페이지가 초기 로드 시 완성된 HTML을 필요로 할 때.

### **RSC가 적합한 경우**

- 초기 로딩 성능이 중요한 대규모 애플리케이션.
- 데이터 중심 UI(예: CMS, 블로그, 대시보드)에서 클라이언트와 서버의 역할을 명확히 분리하고 싶을 때.
- JavaScript 번들 크기를 줄여 네트워크 비용과 로드 시간을 줄이고 싶을 때.

---

## SSR과 RSC의 동작 비교

| **특징**                 | **SSR**                                          | **RSC**                                             |
| ------------------------ | ------------------------------------------------ | --------------------------------------------------- |
| **HTML 생성 방식**       | 서버에서 HTML 생성 후 클라이언트로 전송          | React 컴포넌트 결과를 클라이언트에 전송             |
| **하이드레이션**         | 클라이언트에서 전체 HTML 하이드레이션            | 필요한 클라이언트 컴포넌트만 하이드레이션           |
| **JavaScript 번들 크기** | 서버 컴포넌트도 번들에 포함                      | 서버 컴포넌트는 번들되지 않음                       |
| **초기 로드 성능**       | 번들 크기 증가로 인해 느릴 수 있음               | 최소화된 번들로 초기 로드 성능 개선                 |
| **주요 사용 사례**       | 사용자별 맞춤 데이터를 즉시 렌더링해야 하는 경우 | 데이터 중심 UI, 대규모 애플리케이션, 최적화 필요 시 |

---

## 결론

- **SSR**은 완성된 HTML을 생성해 클라이언트로 전송하고, 하이드레이션을 통해 인터랙티브 UI를 구성.
- **RSC**는 서버에서 컴포넌트를 실행해 UI 트리를 클라이언트로 전달하며, 필요한 JavaScript만 번들링하여 성능을 최적화.
- RSC는 초기 로딩 성능 개선, 클라이언트와 서버 역할 분리, JavaScript 번들 크기 감소 등의 장점으로 Next.js 13에서 기본적으로 권장됩니다.
